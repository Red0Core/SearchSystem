# Обзор алгоритма поиска (на русском)

## Общая идея и чем он полезен
Алгоритм намеренно универсальный: любое пользовательское имя детали переводится в три параллельных представления — нормализованный текст, транслитерация и фонетический ключ. Они индексируются рядом с исходным названием, поэтому запросы на латинице, кириллице, с опечатками или «на слух» сходятся в одну точку. В отличие от жёстких словарей, здесь нет привязки к одному алфавиту или строгому написанию; все ветви работают независимо и комбинируются на этапе запроса.

## Кратко о ходе разработки
- **Шаг 1. Нормализация.** Убрали пунктуацию/повторы, ввели мини-словарь синонимов брендов, чтобы сразу ловить разговорные формы.
- **Шаг 2. Транслитерация.** Добавили явное поле `titleTranslit`, чтобы смешанные раскладки попадали в общий ASCII-контур и могли искаться обычным `multi_match` с fuzziness.
- **Шаг 3. Фонетика.** Перед транслитерацией схлопнули диграфы `sch/sh/zh/ch → ш/ж/ч`, затем применили double metaphone и завели отдельные фонетические поля (`titlePhonetic`, `phonetic`).
- **Шаг 4. Запрос.** Собрали единый Elasticsearch `bool` с параллельными блоками: текстовый, транслитерированный, фонетический и по артикулам. Это дало устойчивость к опечаткам и смешанным раскладкам без лишней сложности в API.

## Что нужно для внедрения
1. **Данные.** При импорте прогонять `title` и `manufacturer` через нормализацию → транслитерацию → фонетику; сохранять все варианты в документе.
2. **Индекс.** Включить фильтр синонимов брендов, транслитерационное поле и фонетические поля в mapping (Beider–Morse/Double Metaphone).
3. **Запрос.** В поиске отправлять исходный текст в параллельные `multi_match` по текстовым, транслитерированным и фонетическим полям плюс блок по артикулам.
4. **Реинжиниринг.** Любое изменение словаря синонимов/фонетики требует переиндексации, потому что токены меняются.

## Проблемы, которые уже закрываются
- Опечатки и съеденные/дублирующиеся буквы (нормализация + fuzziness).
- Смешанные раскладки и латиница/кириллица (транслитерация + asciifolding).
- Разговорные и брендовые синонимы (Python-словарь и ES-фильтр синонимов).
- Поиск «на слух» (фонетические ключи и отдельное фонетическое поле).
- Частичные совпадения и подстроки в артикулах (fuzzy + n-gram фильтры).

## Что пока не идеально
- Семантики нет: алгоритм работает по символам и звукам, а не по смыслу описаний.
- Синонимы статичны: новые бренды/прозвища требуют ручного пополнения и переиндексации.
- Морфология минимальная: нет лемматизации редких форм, покрытие только за счёт fuzziness.
- Составные и иерархические коды не разбираются отдельно — нужен специальный анализатор.
- Ранжирование не учитывает поведение пользователей или бизнес-правила по поставщикам.

## Частный кейс с «коттерьпиллор»
Ранее запрос деградировал до общих результатов, потому что после схлопывания повторов токен превращался в `котерьпилор`, который не попадал в синонимы. Теперь добавлен набор вариантов (`котерпилор`, `котерьпилор`, латинские опечатки) в Python-словарь и в фильтр синонимов индекса. Нормализация сразу превращает такие запросы в `caterpillar`, и они корректно матчятся текстово, транслитерированно и фонетически.
